# SKA CICD OCI Scanning
This playbook allow images running on `docker`, `podman` and `containerd` (`crictl`) to be scanned for vulnerabilities against an inventory of ansible hosts. It automates the process of checking if any of these tools are installed, prepare them for scanning by making sure the required sockets are available and that non-running images are removed, and scan the existing images using Trivy.

The reports generated by Trivy are collected back to the host running this playbook and a python script aggregates them first (to remove duplicates) before reporting to the slack channel `oci-scanning-alerts`.

The repository is setup so that it can be used as a submodule of the deployment repositories, such as [ska-ci-cd-deployment-on-stfc-cloud](https://gitlab.com/ska-telescope/sdi/ska-ci-cd-deployment-on-stfc-cloud), collecting the ansible inventory from the parent repository and targeting those hosts for scanning.

To override this behavior, the variable `INVENTORY_PATH` may be set to a different directory that contains the ansible inventory files. All the inventory files (`inventory_*`) are collected into a common folder and used this way.

To allow the python script to send the reports to slack, the `MARVIN_SLACK_TOKEN` variable must be set with the appropriate token to allow the script to act as Marvin.

# Playbook Organization
The [playbook](playbooks/oci_scan.yml) is divided into 4 roles ([`scan_docker`](playbooks/roles/scan_docker/tasks/main.yml), [`scan_podman`](playbooks/roles/scan_podman/tasks/main.yml), [`scan_containerd`](playbooks/roles/scan_containerd/tasks/main.yml), and [`report_vulnerabilities`](playbooks/roles/report_vulnerabilities/tasks/main.yml)) and a few pre setup and post cleanup tasks to ensure report folders are created/deleted.

The `scan_docker` and `scan_podman` roles are very similar, they check if each ansible host has the tool installed, verifies that their respective socket is available (in the case of podman it checks if the socket service is enabled as well), prunes, lists and then scans the images present on each host. The scan is done using a containerized version of Trivy, sharing a cache between executions to optimize the process. Once all images are scanned, the generated reports are fetched back into the host running the playbook into a temporary folder.

The `scan_containerd` role is slightly different as Trivy does [not currently support containerd](https://github.com/aquasecurity/trivy/issues/851) but may do so in the future. This means that the images running on `containerd` must be pulled into `docker` and scanned there. This occurs only if both `crictl` and `docker` are found in the host, then the images on containerd are pruned, listed, pulled into docker and then scanned. Once the scanning is completed the pulled images are pruned to free up storage.

The `report_vulnerabilities` simply copies the python script and executes it passing the marvin token and the reports to it.